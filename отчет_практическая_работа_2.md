# Практическая работа №2
## по теме "Задание подкласса потока"

---

### Титульный лист

**Министерство науки и высшего образования Российской Федерации**  
**ФГАОУ ВО "Национальный исследовательский технологический университет "МИСиС"**  
**Институт информационных технологий и автоматизированных систем управления**  
**Кафедра инженерной кибернетики**

**Отчет по практической работе №2**  
по дисциплине "Программирование на Python"  
на тему "Задание подкласса потока"

**Выполнил:**  
студент группы ______  
_____________________

**Проверил:**  
преподаватель  
_____________________

**Москва 2026**

---

### Цель работы

1. Изучить принципы создания подклассов класса Thread в Python
2. Научиться управлять жизненным циклом потоков
3. Освоить методы запуска и синхронизации потоков
4. Получить практические навыки работы с многопоточными программами

---

### Ход выполнения работы

#### 1. Анализ исходного кода

Исходный код содержит:
- Класс `MyThreadClass`, наследующий от `Thread`
- Метод `__init__` для инициализации потока
- Метод `run` для выполнения основной логики потока
- Функцию `main` для создания и управления 9 потоками

#### 2. Модификация кода

**Основные изменения:**
- Добавлены подробные комментарии к каждой строке кода
- Изменено количество потоков с 9 на 20
- Оптимизирован код создания потоков с использованием цикла
- Добавлен список для хранения потоков

**Ключевые моменты модификации:**
```python
# Вместо ручного создания 9 потоков:
for i in range(1, 21):  # Создаем 20 потоков
    thread = MyThreadClass("Thread#" + str(i), randint(1, 10))
    threads.append(thread)
```

---

### Результаты выполнения

*[Здесь будут скриншоты выполнения программы]*

**Пример вывода программы:**
```
---> Thread#1 running, belonging to process ID 12345
---> Thread#2 running, belonging to process ID 12345
...
---> Thread#1 over
---> Thread#2 over
...
End
--- 5.234567 seconds ---
```

---

### Выводы

В ходе выполнения практической работы были изучены следующие аспекты:

1. **Наследование от Thread:** Создание подкласса позволяет инкапсулировать логику работы потока внутри класса

2. **Жизненный цикл потока:** 
   - Инициализация в `__init__`
   - Запуск через `start()`
   - Основная работа в `run()`
   - Ожидание завершения через `join()`

3. **Преимущества подхода с подклассом:**
   - Четкое разделение логики
   - Возможность хранения состояния в атрибутах класса
   - Удобство масштабирования

4. **Параллельное выполнение:** Все 20 потоков выполняются одновременно, что демонстрирует эффективность многопоточности

5. **Влияние на производительность:** Общее время выполнения определяется самым долгим потоком, а не суммой всех потоков

---

### Контрольные вопросы

#### 1. Что такое подкласс потока и зачем он нужен?

**Ответ:** Подкласс потока - это класс, наследующий от `Thread`, который позволяет инкапсулировать логику работы потока внутри класса. Это нужно для:
- Организации кода
- Хранения состояния потока в атрибутах
- Повторного использования логики потока

#### 2. В чем разница между методами start() и run()?

**Ответ:** 
- `start()` запускает новый поток и вызывает `run()` в нем
- `run()` выполняется в текущем потоке при прямом вызове
- Для создания многопоточности нужно использовать `start()`

#### 3. Почему важен метод join()?

**Ответ:** `join()` ожидает завершения потока. Без него основной поток может завершиться раньше дочерних, что приведет к преждевременному завершению программы.

#### 4. Как все потоки могут иметь одинаковый ID процесса?

**Ответ:** Все потоки принадлежат одному процессу, поэтому у них одинаковый `os.getpid()`. Различаются они по ID потока (`threading.get_ident()`).

#### 5. Какие преимущества дает использование 20 потоков вместо 9?

**Ответ:** 
- Больше параллельных задач
- Лучшее использование многоядерных процессоров
- Демонстрация масштабируемости подхода
- Более реалистичные сценарии использования

---

### Заключение

Практическая работа успешно выполнена. Изучены принципы создания подклассов потоков, получены навыки управления многопоточными программами. Модифицированный код с 20 потоками демонстрирует эффективность и масштабируемость подхода.
