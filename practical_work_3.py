# Практическая работа №3 по Python на тему "Программирование параллельных алгоритмов на основе потоков с блокировками"
# 
# Данная работа демонстрирует два основных подхода к синхронизации потоков:
# 1. Блокировки (Locks) - для защиты общих ресурсов
# 2. Семафоры (Semaphores) - для координации работы потоков
#
# Цель работы: освоить теоретические основы и методы блокировок при работе потоков,
# написать программы и протестировать их работу в многопоточной среде.

# ЗАДАНИЕ 1 (ЛИСТИНГ 3.1) - РАБОТА С БЛОКИРОВКАМИ
import threading  # Модуль для работы с потоками
import time       # Модуль для работы со временем
import random     # Модуль для генерации случайных чисел

class Box:
    """
    Класс для демонстрации работы с блокировками.
    
    Этот класс имитирует контейнер (коробку) с предметами, которые могут
    добавляться и удаляться несколькими потоками одновременно.
    Без блокировок это привело бы к состоянию гонки (race condition).
    """
    def __init__(self):
        self.lock = threading.RLock()  # Создаем реентерабельную блокировку (RLock)
                                       # RLock позволяет одному потоку получать блокировку несколько раз
        self.total_items = 0           # Инициализируем счетчик предметов
        
    def execute(self, value):
        """
        Безопасный метод для изменения счетчика.
        
        Args:
            value: Значение для добавления к счетчику (+1 или -1)
        """
        with self.lock:  # Контекстный менеджер автоматически получает и освобождает блокировку
            self.total_items += value  # Атомарная операция изменения счетчика
            
    def add(self):
        """
        Метод для безопасного добавления предмета.
        Вызывает execute() с параметром +1.
        """
        with self.lock:  # Получаем блокировку перед доступом к общему ресурсу
            self.execute(1)  # Увеличиваем счетчик на 1
            
    def remove(self):
        """
        Метод для безопасного удаления предмета.
        Вызывает execute() с параметром -1.
        """
        with self.lock:  # Получаем блокировку перед доступом к общему ресурсу
            self.execute(-1)  # Уменьшаем счетчик на 1

def adder(box, items):
    """
    Функция потока-добавителя.
    
    Эта функция работает в отдельном потоке и имитирует добавление предметов
    в общий контейнер. Каждый вызов box.add() безопасен благодаря блокировкам.
    
    Args:
        box: Экземпляр класса Box с общим ресурсом
        items: Количество предметов для добавления
    """
    print("N° {} items to ADD \n".format(items))
    while items:
        box.add()  # Безопасно добавляем предмет (блокировка внутри метода)
        time.sleep(1)  # Имитация работы - задержка 1 секунда
        items -= 1
        print("ADDED one item -->{} item to ADD \n".format(items))

def remover(box, items):
    """
    Функция потока-удалителя.
    
    Эта функция работает в отдельном потоке и имитирует удаление предметов
    из общего контейнера. Работает параллельно с adder().
    
    Args:
        box: Экземпляр класса Box с общим ресурсом
        items: Количество предметов для удаления
    """
    print("N° {} items to REMOVE\n".format(items))
    while items:
        box.remove()  # Безопасно удаляем предмет (блокировка внутри метода)
        time.sleep(1)  # Имитация работы - задержка 1 секунда
        items -= 1
        print("REMOVED one item -->{} item to REMOVE\n".format(items))

def main_task1():
    """
    Главная функция для демонстрации работы с блокировками.
    
    Создает два потока, которые одновременно работают с общим ресурсом:
    - Один добавляет предметы (10-20 штук)
    - Другой удаляет предметы (1-10 штук)
    
    Благодаря блокировкам операции выполняются безопасно без состояний гонки.
    """
    items = 10  # Начальное количество предметов (не используется в логике)
    box = Box()  # Создаем экземпляр класса Box с общим ресурсом
    
    # Создаем потоки с случайным количеством предметов для демонстрации
    t1 = threading.Thread(target=adder, args=(box, random.randint(10,20)))
    t2 = threading.Thread(target=remover, args=(box, random.randint(1,10)))
    
    t1.start()  # Запускаем поток-добавитель
    t2.start()  # Запускаем поток-удалитель
    
    t1.join()   # Ожидаем завершения потока-добавителя
    t2.join()   # Ожидаем завершения потока-удалителя
    
    print(f"Final total items: {box.total_items}")  # Выводим итоговое количество

# ЗАДАНИЕ 2 (ЛИСТИНГ 3.2) - СЕМАФОРЫ И МОДИФИКАЦИИ
# 
# Семафоры - это примитив синхронизации, который позволяет ограничить доступ
# к общему ресурсу или координировать работу потоков. В отличие от блокировок,
# семафоры могут разрешать доступ нескольким потокам одновременно.
import logging  # Модуль для логирования событий программы

# Настройка формата логирования для отслеживания работы потоков
LOG_FORMAT = '%(asctime)s %(threadName)-17s %(levelname)-8s %(message)s'
logging.basicConfig(level=logging.INFO, format=LOG_FORMAT)

semaphore = threading.Semaphore(0)  # Создаем семафор с начальным значением 0
                                     # 0 означает, что потребитель будет заблокирован
                                     # до тех пор, пока производитель не вызовет release()
item = 0  # Глобальная переменная для хранения созданного предмета

def consumer():
    """Функция потока-потребителя"""
    logging.info('Consumer is waiting')  # Логируем ожидание
    semaphore.acquire()  # Пытаемся получить семафор (блокируемся)
    logging.info('Consumer notify: item number {}'.format(item))  # Логируем получение предмета

def producer():
    """Функция потока-производителя"""
    global item  # Объявляем использование глобальной переменной
    time.sleep(3)  # Имитация работы
    item = random.randint(0, 1000)  # Генерируем случайный предмет
    logging.info('Producer notify: item number {}'.format(item))  # Логируем создание предмета
    semaphore.release()  # Освобождаем семафор (разблокируем потребителя)

def main_task2():
    """Главная функция для задания 2 с модификациями"""
    start_time = time.time()  # Засекаем время начала выполнения
    
    # Создаем 15 пар потоков (30 потоков всего) вместо 10
    for i in range(15):
        t1 = threading.Thread(target=consumer, name=f'Consumer-{i+1}')
        t2 = threading.Thread(target=producer, name=f'Producer-{i+1}')
        
        t1.start()  # Запускаем потребителя
        t2.start()  # Запускаем производителя
        
        t1.join()   # Ожидаем завершения потребителя
        t2.join()   # Ожидаем завершения производителя
    
    # Выводим время выполнения программы
    end_time = time.time()
    print(f"Total execution time: {end_time - start_time:.2f} seconds")

def main():
    """Главная функция программы"""
    print("=== ЗАДАНИЕ 1: БЛОКИРОВКИ ===")
    main_task1()
    
    print("\n=== ЗАДАНИЕ 2: СЕМАФОРЫ (15 ПОТОКОВ) ===")
    main_task2()

if __name__ == "__main__":
    main()
