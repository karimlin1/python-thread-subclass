# Практическая работа №1

**по дисциплине:** "Программирование на Python"  
**на тему:** "Разработка программы с использованием потоков данных"

---

## Титульный лист

**Министерство науки и высшего образования Российской Федерации**  
**[Название вашего университета]**  
**Институт компьютерных наук и технологий**  

**Кафедра:** Программной инженерии  

**ОТЧЕТ**  
**по практической работе №1**  
**на тему:** "Разработка программы с использованием потоков данных"

**Выполнил:**  
студент группы ИС-201  
студент

**Проверил:**  
[ФИО преподавателя]

**Город**  
**2026**

---

## Тема и цель работы

**Тема:** Разработка программы с использованием потоков данных

**Цель работы:**
- Изучить возможности модуля threading в Python
- Освоить создание и управление потоками
- Научиться передавать параметры в потоки
- Понять принципы параллельного выполнения кода
- Разработать программу, демонстрирующую работу с потоками данных

---

## Краткая теория по модулю threading

### Модуль threading

Модуль `threading` в Python предоставляет высокоуровневый интерфейс для работы с потоками. Потоки позволяют выполнять несколько задач одновременно в рамках одного процесса.

### Основные понятия

**Поток (Thread)** - наименьшая единица выполнения, которая может быть запланирована операционной системой. Каждый поток имеет свой собственный программный счетчик, стек и локальные переменные.

**Параллелизм** - одновременное выполнение нескольких потоков, что позволяет эффективно использовать многоядерные процессоры.

### Основные компоненты модуля threading

1. **Thread** - основной класс для создания потоков
2. **Lock** - примитив синхронизации для предотвращения гонок данных
3. **Event** - объект для синхронизации потоков
4. **Semaphore** - ограничитель доступа к ресурсам
5. **Timer** - поток, который выполняется через указанное время

---

## Полный код программы

```python
# Практическая работа №1 по Python на тему "Разработка программы с использованием потоков данных"
# Импортируем необходимые модули
import threading  # Модуль для работы с потоками
import time        # Модуль для работы со временем

# Функция my_func из методички - принимает номер потока и выводит сообщение
def my_func(thread_number):
    """Функция, которая выводит сообщение о том, какой поток ее вызвал"""
    print(f"my_func called by thread N°{thread_number}")

# Основные функции для демонстрации работы потоков
def function_A():
    """Функция A - демонстрирует базовую работу потока"""
    print(f"Имя текущего потока: {threading.current_thread().name}")
    print("--> starting function_A")
    time.sleep(2)  # Имитация работы в течение 2 секунд
    print("--> exiting function_A")

def function_B():
    """Функция B - демонстрирует базовую работу потока"""
    print(f"Имя текущего потока: {threading.current_thread().name}")
    print("--> starting function_B")
    time.sleep(2)  # Имитация работы в течение 2 секунд
    print("--> exiting function_B")

def function_C():
    """Функция C - демонстрирует базовую работу потока"""
    print(f"Имя текущего потока: {threading.current_thread().name}")
    print("--> starting function_C")
    time.sleep(2)  # Имитация работы в течение 2 секунд
    print("--> exiting function_C")

# Дополнительные функции с арифметическими вычислениями
def function_add():
    """Функция сложения - складывает два числа и выводит результат"""
    print(f"Имя текущего потока: {threading.current_thread().name}")
    print("--> starting function_add")
    a = 15  # Первое число
    b = 7   # Второе число
    result = a + b  # Складываем числа
    print(f"Результат сложения {a} + {b} = {result}")
    print("--> exiting function_add")

def function_multiply():
    """Функция умножения - умножает два числа и выводит результат"""
    print(f"Имя текущего потока: {threading.current_thread().name}")
    print("--> starting function_multiply")
    a = 8   # Первое число
    b = 9   # Второе число
    result = a * b  # Умножаем числа
    print(f"Результат умножения {a} * {b} = {result}")
    print("--> exiting function_multiply")

# Основная часть программы
if __name__ == "__main__":
    print("=== Начало выполнения программы с потоками ===")
    
    # Создаем 5 потоков с функцией my_func для демонстрации передачи номера
    threads_my_func = []
    for i in range(1, 6):  # Создаем потоки с номерами от 1 до 5
        thread = threading.Thread(target=my_func, args=(i,))
        threads_my_func.append(thread)
    
    # Создаем 5 потоков с именами для разных функций
    threads_functions = []
    
    # Поток для функции A
    thread_A = threading.Thread(target=function_A, name="Поток-A")
    threads_functions.append(thread_A)
    
    # Поток для функции B
    thread_B = threading.Thread(target=function_B, name="Поток-B")
    threads_functions.append(thread_B)
    
    # Поток для функции C
    thread_C = threading.Thread(target=function_C, name="Поток-C")
    threads_functions.append(thread_C)
    
    # Поток для функции сложения
    thread_add = threading.Thread(target=function_add, name="Поток-Сложение")
    threads_functions.append(thread_add)
    
    # Поток для функции умножения
    thread_multiply = threading.Thread(target=function_multiply, name="Поток-Умножение")
    threads_functions.append(thread_multiply)
    
    print("\n--- Запуск потоков my_func ---")
    # Запускаем все потоки с my_func
    for thread in threads_my_func:
        thread.start()
    
    print("\n--- Запуск потоков с именами ---")
    # Запускаем все потоки с именами
    for thread in threads_functions:
        thread.start()
    
    print("\n--- Ожидание завершения потоков my_func ---")
    # Ожидаем завершения всех потоков my_func
    for thread in threads_my_func:
        thread.join()
    
    print("\n--- Ожидание завершения потоков с именами ---")
    # Ожидаем завершения всех потоков с именами
    for thread in threads_functions:
        thread.join()
    
    print("\n=== Все потоки завершены. Программа закончила работу ===")
```

---

## Результат выполнения программы

```
=== Начало выполнения программы с потоками ===

--- Запуск потоков my_func ---
my_func called by thread N°1
my_func called by thread N°2
my_func called by thread N°3
my_func called by thread N°4
my_func called by thread N°5

--- Запуск потоков с именами ---
Имя текущего потока: Поток-A
--> starting function_A
Имя текущего потока: Поток-B
--> starting function_B
Имя текущего потока: Поток-C
--> starting function_C
Имя текущего потока: Поток-Сложение
--> starting function_add
Имя текущего потока: Поток-Умножение
--> starting function_multiply
Результат сложения 15 + 7 = 22
--> exiting function_add
Результат умножения 8 * 9 = 72
--> exiting function_multiply
--- Ожидание завершения потоков my_func ---

--- Ожидание завершения потоков с именами ---
--> exiting function_B
--> exiting function_A
--> exiting function_C

=== Все потоки завершены. Программа закончила работу ===
```

---

## Анализ результатов

При анализе результатов выполнения программы можно отметить следующие важные моменты:

1. **Параллельное выполнение:** Потоки запускаются и выполняются одновременно, что видно из перемешанного вывода сообщений.

2. **Передача параметров:** Функция `my_func` успешно принимает номера потоков через параметр `args=(i,)`.

3. **Именование потоков:** Потокам присвоены осмысленные имена ("Поток-A", "Поток-B" и т.д.), которые выводятся через `threading.current_thread().name`.

4. **Асинхронность:** Порядок завершения потоков не соответствует порядку их запуска, что подтверждает асинхронный характер выполнения.

5. **Синхронизация:** Метод `join()` корректно ожидает завершения всех потоков перед завершением основной программы.

6. **Арифметические операции:** Функции сложения и умножения успешно выполняют вычисления и выводят результаты.

---

## Вывод

В ходе выполнения практической работы были изучены основные возможности модуля `threading` в Python. Была разработана программа, которая демонстрирует:

- Создание потоков с различными целевыми функциями
- Передачу параметров в потоки
- Именование потоков для удобства отладки
- Параллельное выполнение нескольких задач
- Синхронизацию потоков с использованием метода `join()`

Практическая работа показала, что потоки являются эффективным инструментом для организации параллельных вычислений в Python. Программа успешно выполняет все поставленные задачи и демонстрирует корректную работу с потоками данных.

---

## Ответы на контрольные вопросы

### 1. Что такое параллельные вычисления?

**Параллельные вычисления** - это способ организации вычислительного процесса, при котором несколько операций выполняются одновременно. В контексте потоков это означает, что несколько потоков могут выполняться в одно и то же время, используя разные ядра процессора или переключаясь между собой на одном ядре.

**Преимущества параллельных вычислений:**
- Увеличение производительности за счет одновременного выполнения задач
- Эффективное использование многоядерных процессоров
- Улучшение отзывчивости приложений

### 2. Классификация Флинна

**Классификация Флинна** - это система классификации компьютерных архитектур, основанная на количестве потоков инструкций и потоков данных. Включает четыре категории:

1. **SISD (Single Instruction, Single Data)** - одна инструкция, одни данные
   - Пример: классическая однопроцессорная система

2. **SIMD (Single Instruction, Multiple Data)** - одна инструкция, множество данных
   - Пример: векторные процессоры, GPU

3. **MISD (Multiple Instruction, Single Data)** - множество инструкций, одни данные
   - Пример: отказоустойчивые системы

4. **MIMD (Multiple Instruction, Multiple Data)** - множество инструкций, множество данных
   - Пример: многоядерные процессоры, распределенные системы

### 3. Что такое поток данных?

**Поток данных (Data Stream)** - это последовательность данных, которая передается или обрабатывается как единое целое. В контексте многопоточности:

- **Поток данных** может представлять собой непрерывный поток информации между потоками
- **Поток выполнения (Thread)** - это последовательность выполнения инструкций
- **Поток данных** обеспечивает передачу информации между параллельно выполняющимися процессами

### 4. Основные составляющие модуля threading

**Основные компоненты модуля threading:**

1. **Thread** - основной класс для создания потоков
2. **Lock** - примитив синхронизации для взаимоисключения
3. **RLock** - реентерабельный блокировщик
4. **Condition** - условная переменная для синхронизации
5. **Semaphore** - счетчик для ограничения доступа к ресурсам
6. **BoundedSemaphore** - ограниченный семафор
7. **Event** - объект для сигнализации между потоками
8. **Timer** - поток с задержкой запуска
9. **Barrier** - барьер синхронизации

### 5. Класс Thread и его составляющие (с примерами)

**Класс Thread** - основной класс для создания и управления потоками.

**Основные атрибуты и методы:**

```python
import threading
import time

# Создание потока
def my_function(name):
    print(f"Привет, {name}!")
    time.sleep(1)
    print(f"Пока, {name}!")

# 1. Создание потока с целевой функцией
thread = threading.Thread(target=my_function, args=("Анна",))

# 2. Создание потока с именем
thread_named = threading.Thread(target=my_function, args=("Петр",), name="Поток-Петра")

# 3. Основные методы
thread.start()        # Запуск потока
thread.join()         # Ожидание завершения потока
thread.is_alive()     # Проверка, выполняется ли поток
thread.ident          # Идентификатор потока (только для чтения)

# 4. Атрибуты потока
print(thread_named.name)  # Имя потока
print(thread_named.daemon)  # Флаг демона

# 5. Создание потока через наследование
class MyThread(threading.Thread):
    def __init__(self, name):
        super().__init__(name=name)
    
    def run(self):
        print(f"Запуск потока {self.name}")
        time.sleep(2)
        print(f"Завершение потока {self.name}")

# Использование наследуемого потока
custom_thread = MyThread("Пользовательский поток")
custom_thread.start()
custom_thread.join()
```

**Важные особенности класса Thread:**
- **target** - функция, которую будет выполнять поток
- **args** - кортеж аргументов для целевой функции
- **kwargs** - словарь именованных аргументов
- **name** - имя потока для идентификации
- **daemon** - флаг демона (потоки-демоны завершаются при выходе из программы)

---

## Ссылка на код

**Файл с программой:** `main.py`  
**Файл с отчетом:** `отчет_практическая_работа_1.md`  
**Репозиторий:** `c:/Users/karimm/CascadeProjects/splitwise/`

---

## Приложения

### Приложение А. Скриншот выполнения программы

*[Здесь будет скриншот терминала с результатами выполнения программы]*

### Приложение Б. Схема работы потоков

```
Основной поток
    ├── Создает 5 потоков my_func
    │   ├── Поток 1: my_func(1)
    │   ├── Поток 2: my_func(2)
    │   ├── Поток 3: my_func(3)
    │   ├── Поток 4: my_func(4)
    │   └── Поток 5: my_func(5)
    ├── Создает 5 именованных потоков
    │   ├── Поток-A: function_A()
    │   ├── Поток-B: function_B()
    │   ├── Поток-C: function_C()
    │   ├── Поток-Сложение: function_add()
    │   └── Поток-Умножение: function_multiply()
    ├── Запускает все потоки
    ├── Ожидает завершения
    └── Завершает программу
```

---

**Отчет выполнен**  
**Дата:** 24.02.2026
